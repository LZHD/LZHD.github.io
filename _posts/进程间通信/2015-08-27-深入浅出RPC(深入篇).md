---
layout : life
title : 深入浅出RPC——深入篇(转载)
category : 进程间通信
duoshuo: true
date : 2015-08-27
---

******

本文转载自[这里是原文][0]

《深入篇》我们主要围绕 RPC 的功能目标和实现考量去展开，一个基本的 RPC 框架应该提供什么功能，满足什么要求以及如何去实现它？

<!-- more -->

## RPC 功能目标

**RPC的主要功能呢个目标是让构建分布式计算更加容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性**。为实现该目标，RPC框架提供一种透明的调用机制让使用者不必显式的区分本地调用和远程调用，在前文《浅出篇》给出了一种时间结构，基于stub的是结构来实现，下面我们将细化stub结构的实现。

## RPC调用分类

RPC调用分以下两种：

* 同步调用
> 客户方等待调用执行完成并返回结果

* 异步调用
> 客户调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果，若客户方不关系调用返回结果，则变成单向异步调用，单向调用不用返回结果。

## RPC结构拆解

《浅出篇》给出了一个比较粗粒度的RPC实现概念结构，这里我们进一步细化它该由哪些组件构成，如下图所示：
![示例](/res/img/blog/进程间通信/2014-09-22-1.svg)

RPC服务方通过RpcServer导出远程接口方法，而客户方通过RpcClient去引入远程接口方法。客户方向调用本地方法一样去调用远程方法，RPC框架提供接口的代理实现，实际的调用委托给RpcProxy。代理封装调用信用信息将调用转交给RpcInvoker去实际执行，在客户端的RpcInvoker通过连接器RpcConnector去维持服务器端的通道RpcChannel，并使用RpcProtocol执行协议编码(encode)并将编码后的消息通过通道发给服务方。

RPC服务方的RpcAcceptor去接受客户方的调用请求，同样使用RPCProtocol执行协议解码(decode)。解码后的信息传递给RPCProcessor去控制处理调用过程，最后在委托调用给RPCInvoker去实际执行并返回调用结果。

## RPC组件职责

上面我们进一步拆解了RPC实现结构的哥哥组件部分，下面我们详细说明每个部分的职责：

* 1. RPCServer
> 负责导出接口

* 2. RpcClient
> 负责导入接口

* 3. RpcProxy
> 远程接口代理实现

* 4. RpcInvoker
> 客户方实现：负责编码调用信息，并发送调用信息并等待调用返回。
> 服务方实现：负责调用服务端接口的具体实现并返回调用结果。

* 5. RpcProtocol
> 负责协议编解码

* 6. RpcConnector
> 负责维持客户方和服务方的谅解通道和发送数据到服务方

* 7. RpcAcceptor
> 负责接收客户方的请求并返回处理结果

* 8. RpcProcessor
> 负责在服务方管理调用过程，包括线程池和调用的超时时间等。

* 9. RpcChannel
> 数据传输通道

## RPC实现分析

在进一步拆解了组件并划分了职责以后，这里以在Java平台实现该RPC框架概念模型为例，详细分析下实现中需要考虑的因素：

### 导出远程接口

导出远程接口的意思指的只有导出的接口可以供远程调用，而未导出的接口则不能用，在java中导出接口的代码片段可能如下：

```java
	DemoServer demo = new ...;
    RpcSerber server = new ...;
    server.export(Demoserver.class, demo, options)
```

我们可以导出整个接口也可以更细粒度一点只导出接口中的某些方法，如：

```java
	//只导出Demoserver中签名为hi(string s) 的方法
    server.export(DemoServer.class, demo, "hi", new Class<?>[] {String.class},options)
```

java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？ 这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。 如果前面 DemoService 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现，如：

```java
	DemoService demo   = new ...;
	DemoService demo2  = new ...;
	RpcServer   server = new ...;
	server.export(DemoService.class, demo, options);
	server.export("demo2", DemoService.class, demo2, options);
```

上面 demo2 是另一个实现，我们标记为 demo2 来导出， 那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义。

### 导入远程接口与客户端代理

导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。 目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码， 这种方式下实际导入的过程就是通过代码生成器在编译期完成的。 我所使用过的一些跨语言平台 RPC 框架如 CORBAR、WebService、ICE、Thrift 均是此类方式。

代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。 在 java 中导入接口的代码片段可能如下：

```java
	RpcClient client = new ...;
    DemoServer 	demo = client.refer(DemoServer.class);
    demo.hi("how are you");
```

在 java 中 import 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。 这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。 java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。 动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。 两者权衡起来，个人认为牺牲一些性能来获得代码可读性和可维护性显得更重要。

### 协议编解码

客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。 出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。 我们先看下需要编码些什么信息：

#### 调用编码

1. 接口方法

> 包括接口名、方法名

2. 方法参数

> 包括参数类型、参数值

3. 调用属性

> 包括调用属性信息，例如调用附件隐式参数、调用超时时间等

#### 返回编码

1. 返回结果

> 接口方法中定义的返回值

2. 返回码

> 异常返回码

3. 返回异常信息

> 调用异常信息

除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。 这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。 如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。 下面给出一种概念上的 RPC 协议消息设计格式：

**消息头**

![头信息](/res/img/blog/进程间通信/2014-09-22-2.png)

* magic：协议魔数，为解码设计
* header size: 协议头长度，为扩展设计
* version: 协议版本，为扩展时使用
* st: 消息体序列化类型
* hb: 心跳信息标记，为长连接传输层心跳设计
* ow: 单向消息标记
* rp: 相应消息标记。不置位默认是请求消息
* status code： 响应消息状态码
* reserved: 为字节对齐保留
* message id：消息id
* body size:消息体长度

**消息体**

采用序列化编码，常见有以下格式：

* XML:如webservice(SOAP)
* json: 如json-RPC
* binary: 如thrift,hession,kryo等

格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。 序列化我们关心三个方面：

* 序列化和反序列化的效率，越快越好。
* 序列化后的字节长度，越小越好。
* 序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。

上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。




[0]:http://mindwind.me/blog/2014/09/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%AF%87.html